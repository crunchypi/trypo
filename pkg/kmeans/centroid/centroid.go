/*
This file contains an implementation for 'centroids' in a kmeans context.
The centroid impl here follows the common.Centroid interface.
*/
package centroid

import (
	"sort"
	"trypo/pkg/kmeans/common"
	"trypo/pkg/mathutils"
)

// Iface hint.
var _ common.Centroid = new(Centroid)

// Named parameter funcs. See NewCentroidArgs.KNNSearchFunc.
type vecGenerator = func() ([]float64, bool)
type knnSearchFunc = func(targetVec []float64, vecs vecGenerator, k int) []int

// Centroid T in kmeans context. Implements common.Centroid interface.
type Centroid struct {
	vec           []float64
	DataPoints    []common.DataPoint
	knnSearchFunc knnSearchFunc
	kfnSearchFunc knnSearchFunc
}

// NewCentroidArgs is used as an argument to NewCentroid.
type NewCentroidArgs struct {
	InitVec []float64
	InitCap int
	// KNNSearchFunc will be used for operations where it is necessary to find
	// k-nearest-neighs internally in a centroid; for instance with
	// DistributePayload when removing datapoints/payloads from self and then
	// calculating which receivers are best-fit (nearest) the removed datapoints.
	// The search func must be in the following form:
	//
	// 	Let vecGenerator = func() ([]float64, bool)
	// 	Let knnSearchFunc = func(targetVec []float64, vecs vecGenerator, k int) []int.
	//
	// vecGenerator is defined as an argument to knnSearchFunc, and should
	// be a generator that returns a []float64 representing a vector, and
	// a bool which signals stop. If this is unclear, see payloadVecGenerator() in
	// this file.
	//
	// The knnSearchFunc, as mentioned above, is expected to compare 'targetVec'
	// to all vectors generated by 'vecs' to find 'k' best-fit neighs, using
	// some kind of similarity/distance function (Cosine similarity, for instance).
	// The return is expected to be a slice of indeces referring to vectors
	// from 'vecs'. A known implementation of this, at the moment of writing,
	// is found in trypo/searchutils/knn.go (KNNCos & KNNEuc).
	KNNSearchFunc knnSearchFunc
	// KFNSearchFunc is the same as KNNSearchFunc but should find k furthest
	// neighs as opposed to nearest.
	KFNSearchFunc knnSearchFunc
}

// NewCentroid creates a new centroid with the specified args.
func NewCentroid(args NewCentroidArgs) (*Centroid, bool) {
	if args.KNNSearchFunc == nil || args.KFNSearchFunc == nil {
		return nil, false
	}

	c := Centroid{
		vec:           make([]float64, len(args.InitVec)),
		DataPoints:    make([]common.DataPoint, 0, args.InitCap),
		knnSearchFunc: args.KNNSearchFunc,
		kfnSearchFunc: args.KFNSearchFunc,
	}
	for i, v := range args.InitVec {
		c.vec[i] = v
	}
	return &c, true
}

// Vec returns the vector of a centroid.
func (c *Centroid) Vec() []float64 { return c.vec }

// AddDataPoint adds a DataPoint the relevant centroid. Returns false if the vector
// contained in dp is of different length that the vector of the centroid.
func (c *Centroid) AddDataPoint(dp common.DataPoint) bool {
	if len(dp.Vec()) != len(c.vec) || dp.Expired() {
		return false
	}
	c.DataPoints = append(c.DataPoints, dp)
	return true
}

// rmDataPoint removes an internal DataPoint at an index, this is done unsafely
// (without bounds checking) on purpose. Note, it is a very simple thing but
// was put here for code clarity where this method is called.
func (c *Centroid) rmDataPoint(index int) {
	// _Should_ be re-sliced with O(1) going by Go documentation/code.
	c.DataPoints = append(c.DataPoints[:index], c.DataPoints[index+1:]...)
}

// dataPointVecGenerator creates a generator which iterates through all internal
// data points and returns their vec. Auto-removes expired payloads.
func (c *Centroid) dataPointVecGenerator() func() ([]float64, bool) {
	i := 0
	return func() ([]float64, bool) {
		// Check bounds and skip expired datapoints.
		for i < len(c.DataPoints) && c.DataPoints[i].Expired() {
			c.rmDataPoint(i)
		}
		if i >= len(c.DataPoints) {
			return nil, false
		}
		i++
		return c.DataPoints[i-1].Vec(), true
	}
}

// DrainUnordered drains n internal datapoints in a manner that has no particylar.
// significance, specifically by how they are stored internally -- in no order.
func (c *Centroid) DrainUnordered(n int) []common.DataPoint {
	res := make([]common.DataPoint, 0, n)
	for len(c.DataPoints) != 0 && len(res) < n {
		if !c.DataPoints[0].Expired() {
			res = append(res, c.DataPoints[0])
		}
		c.rmDataPoint(0)
	}
	return res
}

// DrainOrdered drains n internal DataPoints that are furthest away from the
// internal vector of a centroid. Furthest away can mean different things,
// depending on the 'KFNSearchFunc' field used in the 'NewCentroidArgs' struct
// when creating a new Centroid with 'NewCentroid'. If that field is
// net-means/searchutils.KNFCos, then drain away data that has lowest cosine
// similarity to this Centroid.
func (c *Centroid) DrainOrdered(n int) []common.DataPoint {
	res := make([]common.DataPoint, 0, n)
	// Furthest neigh.
	indexes := c.kfnSearchFunc(c.vec, c.dataPointVecGenerator(), n)
	// Sorting because this method will remove datapoints at these indexes, and
	// having things out of order can cause a rugpull (c.DataPoints index shift).
	sort.Ints(indexes)
	for i := len(indexes) - 1; i > -1; i-- { // Backwards for removal safety.
		res = append(res, c.DataPoints[indexes[i]])
		c.rmDataPoint(indexes[i])
	}
	return res
}

// Expire looks through internal datapoints and removes the ones that have
// expired. This needs a follow-up with Centroid.MemTrim() to completely
// free up the space and reduce the internal cap.
func (c *Centroid) Expire() {
	i := 0
	for i < len(c.DataPoints) {
		if c.DataPoints[i].Expired() {
			c.rmDataPoint(i)
			continue
		}
		i++
	}
}

// LenDP returns the number of DataPoints stored internally.
func (c *Centroid) LenDP() int { return len(c.DataPoints) }

// MemTrim creates a new internal DataPoint slice where capacity equals len.
// Note, it's a costly operation.
func (c *Centroid) MemTrim() {
	// @ Currently inefficient since memory is essentially doubled
	// @ while doing this procedure.
	dp := make([]common.DataPoint, 0, len(c.DataPoints))
	for i := 0; i < len(c.DataPoints); i++ {
		if !c.DataPoints[i].Expired() {
			dp = append(dp, c.DataPoints[i])
		}
	}
	c.DataPoints = dp
}

// MoveVector moves the internal centroid vector to be the mean of all
// contained DataPoints.
func (c *Centroid) MoveVector() bool {
	vec, ok := mathutils.VecMean(c.dataPointVecGenerator())
	if ok {
		c.vec = vec
	}
	return ok
}

// DistributeDataPoints removes n internal DataPoints using the DrainOrdered
// method (see documentation for it), which is costly but default as this
// method would auto-distribute the worst internal data. The removed data is
// then added to receivers, which can fail if the receivers can't accept the
// data. In that case, the data goes back into self.
func (c *Centroid) DistributeDataPoints(n int, receivers []common.DataPointReceiver) {
	if receivers == nil || len(receivers) == 0 {
		return
	}
	// Need to have a slice here (i.e can't draw datapoints directly from
	// c.DataPoints) because this instance (c) can be one of the distributers.
	data := c.DrainOrdered(n)
	i := 0
	generator := func() ([]float64, bool) {
		if i >= len(receivers) {
			return nil, false
		}
		i++
		return receivers[i-1].Vec(), true
	}

	for j := 0; j < len(data); j++ {
		i = 0 // Reset generator.
		indexes := c.knnSearchFunc(data[j].Vec(), generator, 1)
		// Put back into self if (1) search failed or (2) adder failed to add.
		if len(indexes) == 0 || !receivers[indexes[0]].AddDataPoint(data[j]) {
			c.AddDataPoint(data[j])
		}
	}
}

// KNNLookup uses the supplied 'vec' to lookup 'n' best-fit DataPoints and
// returns them; 'drain'=true will remove them from self as well. Best fit will
// depend on the 'KFNSearchFunc' field used in the 'NewCentroidArgs' struct when
// crating a new Centroid with 'NewCentroid'. If that field is for instance
// net-means/searchutils.KNNCos, then best fit equals best cosine similarity.
func (c *Centroid) KNNLookup(vec []float64, k int, drain bool) []common.DataPoint {
	res := make([]common.DataPoint, 0, k)

	indexes := c.knnSearchFunc(vec, c.dataPointVecGenerator(), k)
	for _, i := range indexes {
		res = append(res, c.DataPoints[i])
	}

	// Secondary loop because ints in indexes might not be ordered.
	if drain {
		for _, i := range indexes {
			c.rmDataPoint(i)
		}
	}
	return res
}
